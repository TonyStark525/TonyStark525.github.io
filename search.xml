<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>About Me</title>
    <url>/2021/11/21/about/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><blockquote>
<p>一位喜欢rap篮球不喜欢唱跳的牛马</p>
<p>Marvel粉CSGO选手</p>
</blockquote>
<p>姓名：TT<br>现居：湖南<br>GitHub: <a href="https://github.com/TonyStark525">TonyStark525</a><br>QQ: 1832163211<br>微信: Y11J22L</p>
<span id="more"></span>

<!-- ![avatar.jpg](https://i.loli.net/2019/12/02/Hw5WJIMKzi1YrU8.jpg) -->

<img src="http://m.qpic.cn/psc?/V54WCKNt3LsF2t0e6dNA0snyjW1dTM2f/45NBuzDIW489QBoVep5mcZP37T5vtCJuEToa*I2pmOWd5s7v26dv874Ub.DsH43aAmYLNOmjUyMxawY7LmvLFPdfSc6SnvYkeAZelZiQOzQ!/b&bo=dgOkBQAAAAADV6Y!&rf=viewer_4r" width="500" style="border-radius:70%"/>]]></content>
      <tags>
        <tag>随笔</tag>
      </tags>
  </entry>
  <entry>
    <title>重写equals</title>
    <url>/2021/11/20/note/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h1 id="Java重写equals方法（重点讲解）"><a href="#Java重写equals方法（重点讲解）" class="headerlink" title="Java重写equals方法（重点讲解）"></a>Java重写equals方法（重点讲解）</h1><p><strong>为什么equals()方法要重写？</strong></p>
<p>判断两个对象在逻辑上是否相等，如根据类的成员变量来判断两个类的实例是否相等，而继承Object中的equals方法只能判断两个引用变量是否是同一个对象。这样我们往往需要重写equals()方法。</p>
<p>我们向一个没有重复对象的集合中添加元素时，集合中存放的往往是对象，我们需要先判断集合中是否存在已知对象，这样就必须重写equals方法。</p>
<p><strong>怎样重写equals()方法？</strong></p>
<p>重写equals方法的要求：</p>
<p>1、自反性：对于任何非空引用x，x.equals(x)应该返回true。</p>
<p>2、对称性：对于任何引用x和y，如果x.equals(y)返回true，那么y.equals(x)也应该返回true。</p>
<p>3、传递性：对于任何引用x、y和z，如果x.equals(y)返回true，y.equals(z)返回true，那么x.equals(z)也应该返回true。</p>
<p>4、一致性：如果x和y引用的对象没有发生变化，那么反复调用x.equals(y)应该返回同样的结果。</p>
<p>5、非空性：对于任意非空引用x，x.equals(null)应该返回false。</p>
<p><strong>1、自反性原则</strong></p>
<p>在JavaBean中，经常会覆写equals方法，从而根据实际业务情况来判断两个对象是否相等，比如我们写一个person类，根据姓名来判断两个person类实例对象是否相等。代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"> <span class="number">1</span> <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line"> <span class="number">2</span>     <span class="keyword">private</span> String name;</span><br><span class="line"> <span class="number">3</span> </span><br><span class="line"> <span class="number">4</span>     <span class="function"><span class="keyword">public</span> <span class="title">Person</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line"> <span class="number">5</span>         <span class="keyword">this</span>.name = name;</span><br><span class="line"> <span class="number">6</span>     &#125;</span><br><span class="line"> <span class="number">7</span> </span><br><span class="line"> <span class="number">8</span>     <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line"> <span class="number">9</span>         <span class="keyword">return</span> name;</span><br><span class="line"><span class="number">10</span>     &#125;</span><br><span class="line"><span class="number">11</span> </span><br><span class="line"><span class="number">12</span>     <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line"><span class="number">13</span>         <span class="keyword">this</span>.name = name;</span><br><span class="line"><span class="number">14</span>     &#125;</span><br><span class="line"><span class="number">15</span> </span><br><span class="line"><span class="number">16</span>     <span class="meta">@Override</span></span><br><span class="line"><span class="number">17</span>     <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object obj)</span> </span>&#123;</span><br><span class="line"><span class="number">18</span>         <span class="keyword">if</span> (obj <span class="keyword">instanceof</span> Person) &#123;</span><br><span class="line"><span class="number">19</span>             Person person = (Person) obj;</span><br><span class="line"><span class="number">20</span>             <span class="keyword">return</span> name.equalsIgnoreCase(person.getName().trim());</span><br><span class="line"><span class="number">21</span>         &#125;</span><br><span class="line"><span class="number">22</span>         <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line"><span class="number">23</span>     &#125;</span><br><span class="line"><span class="number">24</span> </span><br><span class="line"><span class="number">25</span>     <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"><span class="number">26</span>         Person p1 = <span class="keyword">new</span> Person(<span class="string">&quot;张三&quot;</span>);</span><br><span class="line"><span class="number">27</span>         Person p2 = <span class="keyword">new</span> Person(<span class="string">&quot;张三    &quot;</span>);</span><br><span class="line"><span class="number">28</span>         List&lt;Person&gt; list = <span class="keyword">new</span> ArrayList&lt;Person&gt;();</span><br><span class="line"><span class="number">29</span>         list.add(p1);</span><br><span class="line"><span class="number">30</span>         list.add(p2);</span><br><span class="line"><span class="number">31</span>         System.out.println(<span class="string">&quot;是否包含张三：&quot;</span> + list.contains(p1));</span><br><span class="line"><span class="number">32</span>         System.out.println(<span class="string">&quot;是否包含张三：&quot;</span> + list.contains(p2));</span><br><span class="line"><span class="number">33</span>     &#125;</span><br><span class="line"><span class="number">34</span> &#125;</span><br></pre></td></tr></table></figure>

<p>list中含有这个生成的person对象，结果应该为true，但是实际结果：这里考虑了字符串空格的问题，去除前后的空格。</p>
<p>是否包含张三：true</p>
<p>是否包含张三：false</p>
<p>第二个为什么会是false呢？</p>
<p>原因在于list中检查是否含有元素时是通过调用对象的equals方法来判断的，也就是说 contains（p2）传递进去会依次执行p2.equals(p1)、p2.equals(p2)，只要一个返回true，结果就是true。但是这里p2.equals(p2)返回的是false？由于我们对字符前后进行了空格的切割造成p2.equals(p2)的比较实际上是：“张三  ”.equals（“张三”），一个有空格，一个没有空格就出错了。</p>
<p>这个违背了equals的自反性原则：对于任何非空引用x，x.equals(x)应该返回true。</p>
<p>这里只要去掉trim方法就可以解决。</p>
<p><strong>2、对称性原则</strong></p>
<p>上面这个例子，还并不是很好，如果我们传入null值，会怎么样呢？增加一条语句：Person p2=new Person(null);</p>
<p>结果：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">是否包含张三：true</span><br><span class="line">Exception in thread &quot;main&quot; java.lang.NullPointerException//空指针异常</span><br></pre></td></tr></table></figure>

<p>原因在执行p2.equals(p1)时，由于p2的name是一个null值，所以调用name.equalsIgnoreCase()方法时就会报空指针异常。</p>
<p>这是在覆写equals方法时没有遵循对称性原则：对于任何应用x,y的情形，如果想x.equals(y)返回true，那么y.equals(x),也应该返回true。</p>
<p>应该在equals方法里加上是否为null值的判断：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"> 1 @Override</span><br><span class="line"> 2     public boolean equals(Object obj) &#123;</span><br><span class="line"> 3         if (obj instanceof Person) &#123;</span><br><span class="line"> 4             Person person= (Person) obj;</span><br><span class="line"> 5             if (person.getName() == null || name == null) &#123;</span><br><span class="line"> 6                 return false;</span><br><span class="line"> 7             &#125;else&#123;</span><br><span class="line"> 8                 return name.equalsIgnoreCase(person.getName());</span><br><span class="line"> 9             &#125;</span><br><span class="line">10         &#125;</span><br><span class="line">11         return false;</span><br><span class="line">12     &#125;</span><br></pre></td></tr></table></figure>

<p><strong>3、传递性原则</strong>　　</p>
<p>现在我们有一个Employee类继承自person类：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"> 1 public class Employee extends Person&#123;</span><br><span class="line"> 2     private int id;</span><br><span class="line"> 3   </span><br><span class="line"> 4   </span><br><span class="line"> 5     public int getId() &#123;</span><br><span class="line"> 6         return id;</span><br><span class="line"> 7     &#125;</span><br><span class="line"> 8     public void setId(int id) &#123;</span><br><span class="line"> 9         this.id = id;</span><br><span class="line">10     &#125;</span><br><span class="line">11     public Employee(String name,int id) &#123;</span><br><span class="line">12         super(name);</span><br><span class="line">13         this.id = id;</span><br><span class="line">14         // TODO Auto-generated constructor stub</span><br><span class="line">15     &#125;</span><br><span class="line">16     @Override</span><br><span class="line">17     public boolean equals(Object obj) &#123;</span><br><span class="line">18         if(obj instanceof Employee)&#123;</span><br><span class="line">19             Employee e = (Employee)obj;</span><br><span class="line">20             return super.equals(obj) &amp;&amp; e.getId() == id;</span><br><span class="line">21         &#125;</span><br><span class="line">22         return super.equals(obj);</span><br><span class="line">23     &#125;</span><br><span class="line">24   </span><br><span class="line">25     public static void main(String[] args)&#123;</span><br><span class="line">26         Employee e1=new Employee(&quot;张三&quot;,12);</span><br><span class="line">27         Employee e2=new Employee(&quot;张三&quot;,123);</span><br><span class="line">28         Person p1 = new Person(&quot;张三&quot;);</span><br><span class="line">29   </span><br><span class="line">30         System.out.println(p1.equals(e1));</span><br><span class="line">31         System.out.println(p1.equals(e2));</span><br><span class="line">32         System.out.println(e1.equals(e2));</span><br><span class="line">33     &#125;</span><br><span class="line">34 &#125;</span><br></pre></td></tr></table></figure>

<p>只有在name和ID都相同的情况下才是同一个员工，避免同名同姓的。在main里定义了，两个员工和一个社会闲杂人员，虽然同名同姓但肯定不是同一个人。运行结果应该三个都是false才对。但是：</p>
<p>true</p>
<p>true</p>
<p>false</p>
<p>p1尽然等于e1,也等于e2，不是同一个类的实例也相等了？</p>
<p>因为p1.equals(e1)是调用父类的equals方法进行判断的它使用instanceof关键字检查e1是否是person的实例，由于employee和person是继承关系，结果就是true了。但是放过来就不成立，e1,e2就不等于p1，这也是违反对称性原则的一个典型案例。</p>
<p>e1竟然不等于e2？</p>
<p>e1.equals(e2)调用的是Employee的equals方法，不仅要判断姓名相同还有判断工号相同，两者的工号不同，不相等时对的。但是p1等于e1,也等于e2，e1却不等于e2，这里就存在矛盾，等式不传递是因为违反了equals的传递性原则：对于实例对象x、y、z；如果x.equals(y)返回true，y.equals(z)返回true，那么x.equals(z)也应该返回true。</p>
<p>上述情况会发生是因为父类使用instanceof关键字(是否是这个特定类或者是它的子类的一个实例)，用来判断是否是一个类的实例对象的，这很容易让子类“钻空子”。</p>
<p>想要解决也很简单，使用getClass进行类型的判断，person类的equals方法修改如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"> 1 @Override</span><br><span class="line"> 2     public boolean equals(Object obj) &#123;</span><br><span class="line"> 3         if (obj != null &amp;&amp; obj.getClass() == this.getClass()) &#123;</span><br><span class="line"> 4             Person person= (Person) obj;</span><br><span class="line"> 5             if (person.getName() == null || name == null) &#123;</span><br><span class="line"> 6                 return false;</span><br><span class="line"> 7             &#125;else&#123;</span><br><span class="line"> 8                 return name.equalsIgnoreCase(person.getName());</span><br><span class="line"> 9             &#125;</span><br><span class="line">10         &#125;</span><br><span class="line">11         return false;</span><br><span class="line">12 &#125;</span><br></pre></td></tr></table></figure>

<p><strong>4、必须覆写hashCode方法这样结果就是三个false。</strong></p>
<p>覆写equals方法就必须覆写hashCode方法，这是Javaer都知道的。</p>
<p>原因就是HashMap的底层处理机制是以数组的方式保存map条目的，这其中的关键是这个数组下标的处理机制：</p>
<p>依据传入元素的hashCode方法的返回值决定其数组的下标，如果该数组位置上已经有了map条目，且与传入的键值相等则不处理，若不相等则覆盖；如果数组位置没有条目，则插入，并加入到map条目的链表中。同理检查键是否存在也是根据哈希吗确定文职，然后遍历查找键值的。</p>
<p>那么对象的hashCode方法返回的是什么呢？</p>
<p>他是一个对象的哈希码，是有Object类的本地方法生成的，确保每个对象有一个哈希码。</p>
<p>1、重写equals方法实例  部分代码参考<a href="http://blog.csdn.net/wangloveall/article/details/7899948">http://blog.csdn.net/wangloveall/article/details/7899948</a></p>
<p>重写equals方法的目的是判断两个对象的内容(内容可以有很多，比如同时比较姓名和年龄，同时相同的才是用一个对象)是否相同。</p>
<p>如果不重写equals，那么比较的将是对象的引用是否指向同一块内存地址，重写之后目的是为了比较两个对象的value值是否相等。特别指出利用equals比较八大包装对象，（如int，float等）和String类（因为该类已重写了equals和hashcode方法）对象时，默认比较的是值，在比较其它自定义对象时都是比较的引用地址。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">package com.lk.C;</span><br><span class="line"></span><br><span class="line">class User &#123;</span><br><span class="line">    private String name;</span><br><span class="line">    private int age;</span><br><span class="line">    public int getAge() &#123;</span><br><span class="line">        return age;</span><br><span class="line">    &#125;</span><br><span class="line">    public void setAge(int age) &#123;</span><br><span class="line">        this.age = age;</span><br><span class="line">    &#125;</span><br><span class="line">    public void setName(String name) &#123;  </span><br><span class="line">        this.name = name;  </span><br><span class="line">    &#125;</span><br><span class="line">    public String getName() &#123;  </span><br><span class="line">        return name;  </span><br><span class="line">    &#125;</span><br><span class="line">    public boolean equals(Object obj) &#123;  </span><br><span class="line">        if(this == obj) &#123;  </span><br><span class="line">            return true;  </span><br><span class="line">        &#125;  </span><br><span class="line">        if(null == obj) &#123;  </span><br><span class="line">            return false;  </span><br><span class="line">        &#125;  </span><br><span class="line">        if(this.getClass() != obj.getClass()) &#123;  </span><br><span class="line">            return false;  </span><br><span class="line">        &#125;  </span><br><span class="line"></span><br><span class="line">        User user = (User) obj;  </span><br><span class="line">        if(this.name.equals(user.name)&amp;&amp;this.age == user.age) &#123;  </span><br><span class="line">            return true;  </span><br><span class="line">        &#125;  </span><br><span class="line">        return false;  </span><br><span class="line">    &#125;  </span><br><span class="line">    </span><br><span class="line">&#125;  </span><br><span class="line"></span><br><span class="line">public class Test6 &#123;  </span><br><span class="line">    public static void main(String[] args) &#123;  </span><br><span class="line">        User userA = new User();  </span><br><span class="line">        userA.setName(&quot;王明&quot;);</span><br><span class="line">        userA.setAge(10);</span><br><span class="line"></span><br><span class="line">        User userB = new User();  </span><br><span class="line">        userB.setName(&quot;王明&quot;);</span><br><span class="line">        userB.setAge(10);</span><br><span class="line"></span><br><span class="line">        User userC = new User();  </span><br><span class="line">        userC.setName(&quot;王亮&quot;);</span><br><span class="line">        userC.setAge(10);</span><br><span class="line"></span><br><span class="line">        System.out.println(&quot;userA equals userB:&quot; + userA.equals(userB));  </span><br><span class="line">        System.out.println(&quot;userA equals userC:&quot; + userA.equals(userC));</span><br><span class="line">    &#125;  </span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">userA equals userB:true</span><br><span class="line">userA equals userC:false</span><br></pre></td></tr></table></figure>

<p>在Java中，问什么说重写了equals方法都要进而重写Hashcode方法呢？</p>
<p>原因如下：当equals此方法被重写时，通常有必要重写 hashCode 方法，以维护 hashCode 方法的常规协定，该协定声明相等对象必须具有相等的哈希码。如下：</p>
<p>(1)当obj1.equals(obj2)为true时，obj1.hashCode() == obj2.hashCode()必须为true</p>
<p>(2)当obj1.hashCode() == obj2.hashCode()为false时，obj1.equals(obj2)必须为false</p>
<p>hashcode是用于散列数据的快速存取，如利用HashSet/HashMap/Hashtable类来存储数据时，都是根据存储对象的hashcode值来进行判断是否相同的。</p>
<p>这样如果我们对一个对象重写了euqals，意思是只要对象的成员变量值都相等那么euqals就等于true，但不重写hashcode，那么我们再new一个新的对象，当原对象.equals（新对象）等于true时，两者的hashcode却是不一样的，由此将产生了理解的不一致。</p>
<p>2、看看下面的三段程序</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">package com.lk.C;</span><br><span class="line"></span><br><span class="line">public class Test7 &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        int a = 10;</span><br><span class="line">        int b = 10;</span><br><span class="line">        System.out.print(&quot;基本类型a==b:&quot;);</span><br><span class="line">        System.out.println(a == b);</span><br><span class="line">        System.out.println(&quot;-----&quot;);</span><br><span class="line">        </span><br><span class="line">        String s1 = &quot;abc&quot;;</span><br><span class="line">        String s2 = &quot;abc&quot;;</span><br><span class="line">        System.out.print(&quot;String类型是s1==s2:&quot;);</span><br><span class="line">        System.out.println(s1 == s2);</span><br><span class="line">        System.out.println(&quot;-----&quot;);</span><br><span class="line">        </span><br><span class="line">        String s3 = new String(&quot;abc&quot;);</span><br><span class="line">        String s4 = new String(&quot;abc&quot;);//可以看出==比较的是栈的地址是否相同</span><br><span class="line">        System.out.print(&quot;String类型用new String()是s1==s2:&quot;);</span><br><span class="line">        System.out.println(s3 == s4);</span><br><span class="line">        System.out.println(s1 == s3);</span><br><span class="line">        System.out.println(&quot;-----&quot;);</span><br><span class="line">        </span><br><span class="line">        Integer i1 = 1;</span><br><span class="line">        Integer i2 = 1;</span><br><span class="line">        System.out.print(&quot;包装类型是i1==i2:&quot;);</span><br><span class="line">        System.out.println(i1 == i2);</span><br><span class="line">        System.out.println(&quot;-----&quot;);</span><br><span class="line">        </span><br><span class="line">        Integer i3 = 128;</span><br><span class="line">        Integer i4 = 128;//此时输出false是因为Integer在-128-127之间会缓存，超出这个范围就不会缓存了</span><br><span class="line">        System.out.print(&quot;包装类型是i3==i4:&quot;);</span><br><span class="line">        System.out.println(i3 == i4);</span><br><span class="line">        System.out.println(&quot;-----&quot;);</span><br><span class="line">        </span><br><span class="line">        Integer i5 = new Integer(&quot;1&quot;);</span><br><span class="line">        Integer i6 = new Integer(&quot;1&quot;);</span><br><span class="line">        System.out.print(&quot;包装类型用new Integer()是i5==i6:&quot;);</span><br><span class="line">        System.out.println(i5 == i6);//用new Integer()多少都不会缓存</span><br><span class="line">        System.out.println(&quot;-----&quot;);</span><br><span class="line">        </span><br><span class="line">        A a1 = new A(1);</span><br><span class="line">        A a2 = new A(1);</span><br><span class="line">        A a3 = a2;</span><br><span class="line">        System.out.print(&quot;普通引用类型a1 == a2：&quot;);</span><br><span class="line">        System.out.println(a1 == a2);</span><br><span class="line">        System.out.println(a2 == a3);//对象赋给新对象连地址都是相同的</span><br><span class="line">        System.out.println(&quot;-----&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class A&#123;</span><br><span class="line">    int i;</span><br><span class="line">    public A(int i)&#123;</span><br><span class="line">        this.i = i;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">基本类型a==b:true</span><br><span class="line">-----</span><br><span class="line">String类型是s1==s2:true</span><br><span class="line">-----</span><br><span class="line">String类型用new String()是s1==s2:false</span><br><span class="line">false</span><br><span class="line">-----</span><br><span class="line">包装类型是i1==i2:true</span><br><span class="line">-----</span><br><span class="line">包装类型是i3==i4:false</span><br><span class="line">-----</span><br><span class="line">包装类型用new Integer()是i5==i6:false</span><br><span class="line">-----</span><br><span class="line">普通引用类型a1 == a2：false</span><br><span class="line">true</span><br><span class="line">-----</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">package com.lk.C;</span><br><span class="line"></span><br><span class="line">public class Test8 &#123;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        // TODO Auto-generated method stub</span><br><span class="line">        System.out.println(&quot;基本类型没有equals方法&quot;);</span><br><span class="line">        System.out.println(&quot;-----&quot;);</span><br><span class="line">        </span><br><span class="line">        String s1 = &quot;abc&quot;;</span><br><span class="line">        String s2 = &quot;abc&quot;;</span><br><span class="line">        System.out.print(&quot;String类型的equals方法:&quot;);</span><br><span class="line">        System.out.println(s1.equals(s2));</span><br><span class="line">        System.out.println(&quot;-----&quot;);</span><br><span class="line">        </span><br><span class="line">        String s3 = new String(&quot;abc&quot;);</span><br><span class="line">        String s4 = new String(&quot;abc&quot;);//可以看出比较equals方法比较的是堆里的值是否相同</span><br><span class="line">        System.out.print(&quot;String类型的new String()的equals方法：&quot;);</span><br><span class="line">        System.out.println(s3.equals(s4));</span><br><span class="line">        System.out.println(&quot;-----&quot;);</span><br><span class="line">        </span><br><span class="line">        System.out.print(&quot;String用==赋值和用new String()赋值的比较：&quot;);</span><br><span class="line">        System.out.println(s1.equals(s3));</span><br><span class="line">        System.out.println(&quot;-----&quot;);</span><br><span class="line">        </span><br><span class="line">        Integer i1 = 1;</span><br><span class="line">        Integer i2 = 1;</span><br><span class="line">        System.out.print(&quot;包装类的equals方法：&quot;);</span><br><span class="line">        System.out.println(i1.equals(i2));</span><br><span class="line">        System.out.println(&quot;-----&quot;);</span><br><span class="line">        </span><br><span class="line">        Integer i3 = new Integer(1);</span><br><span class="line">        Integer i4 = new Integer(1);</span><br><span class="line">        System.out.print(&quot;包装类的new Integer()用equals方法：&quot;);</span><br><span class="line">        System.out.println(i3.equals(i4));</span><br><span class="line">        System.out.println(&quot;-----&quot;);</span><br><span class="line">        </span><br><span class="line">        System.out.print(&quot;Integer用==赋值和用new Integer()赋值的比较：&quot;);</span><br><span class="line">        System.out.println(i1.equals(i3));</span><br><span class="line">        System.out.println(&quot;-----&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">基本类型没有equals方法</span><br><span class="line">-----</span><br><span class="line">String类型的equals方法:true</span><br><span class="line">-----</span><br><span class="line">String类型的new String()的equals方法：true</span><br><span class="line">-----</span><br><span class="line">String用==赋值和用new String()赋值的比较：true</span><br><span class="line">-----</span><br><span class="line">包装类的equals方法：true</span><br><span class="line">-----</span><br><span class="line">包装类的new Integer()用equals方法：true</span><br><span class="line">-----</span><br><span class="line">Integer用==赋值和用new Integer()赋值的比较：true</span><br><span class="line">-----</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">package com.lk.C;</span><br><span class="line"></span><br><span class="line">public class Test9 &#123;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        // TODO Auto-generated method stub</span><br><span class="line">        Student s1 = new Student(&quot;阿坤&quot;,21);</span><br><span class="line">        Student s2 = new Student(&quot;阿坤&quot;,21);</span><br><span class="line">        Student s3 = new Student();</span><br><span class="line">        Student s4 = new Student();</span><br><span class="line">        Student s5 = s1;</span><br><span class="line">        System.out.print(&quot;普通类对象的==非默认构造：&quot;);</span><br><span class="line">        System.out.println(s1 == s2);</span><br><span class="line">        System.out.println(s1 == s5);</span><br><span class="line">        System.out.println(&quot;-----&quot;);</span><br><span class="line">        </span><br><span class="line">        System.out.print(&quot;普通类对象的equals非默认构造：&quot;);</span><br><span class="line">        System.out.println(s1.equals(s2));</span><br><span class="line">        System.out.println(s1.equals(s5));</span><br><span class="line">        System.out.println(&quot;-----&quot;);</span><br><span class="line">        </span><br><span class="line">        System.out.print(&quot;普通类对象的==默认构造：&quot;);</span><br><span class="line">        System.out.println(s3 == s4);</span><br><span class="line">        System.out.println(&quot;-----&quot;);</span><br><span class="line">        </span><br><span class="line">        System.out.print(&quot;普通类对象的equals默认构造：&quot;);</span><br><span class="line">        System.out.println(s3.equals(s4));</span><br><span class="line">        System.out.println(&quot;-----&quot;);</span><br><span class="line">        </span><br><span class="line">        System.out.print(&quot;对普通对象的属性进行比较equals：&quot;);</span><br><span class="line">        System.out.println(s1.name.equals(s2.name));</span><br><span class="line">        System.out.print(&quot;对普通对象的属性进行比较==：&quot;);</span><br><span class="line">        System.out.println(s1.name == s2.name);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">class Student&#123;</span><br><span class="line">    public String name;</span><br><span class="line">    public int age;</span><br><span class="line">    public Student()&#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    public Student(String name,int age)&#123;</span><br><span class="line">        this.name = name;</span><br><span class="line">        this.age = age;</span><br><span class="line">    &#125;</span><br><span class="line">    public void test()&#123;</span><br><span class="line">        System.out.println(this.name);</span><br><span class="line">        System.out.println(this.age);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">普通类对象的==非默认构造：false</span><br><span class="line">true</span><br><span class="line">-----</span><br><span class="line">普通类对象的equals非默认构造：false</span><br><span class="line">true</span><br><span class="line">-----</span><br><span class="line">普通类对象的==默认构造：false</span><br><span class="line">-----</span><br><span class="line">普通类对象的equals默认构造：false</span><br><span class="line">-----</span><br><span class="line">对普通对象的属性进行比较equals：true</span><br><span class="line">对普通对象的属性进行比较==：true</span><br></pre></td></tr></table></figure>

<p>从以上的三个程序可以看出：</p>
<p>1)对于==：在简单类型中(int等)，这能使用该方法进行比较，这种类型没有equals方法，int的值是存在栈中的，==比较的是栈的内容是否相同。在String类型中，比较特殊，用String=“”；这种进行赋值时，两个相同的值用==比较也是相同的。但是用new String()，赋值就不相同。说明String=“”时，java会检查在堆中是否由相同的值，如果有，把新对象的地址也同老对象的地址赋为相同，因此==比较会相同。但是new String()开辟的就是两个栈，因此用==比较不会相同。对于包装类，如Integer=“”；时，在-128-127会有缓存，请看上面程序。其他的情况与String类似。</p>
<p>2)对于equals：当时String类型或者是包装类，如Integer时，比较的就是堆中的值，Integer也无缓存之说。对于普通类，equals比较的内存的首地址，这时候和==是一样的，即比较两边指向的是不是同一个对象。详细请见程序三。</p>
<p>以上程序都是亲自测试过。希望能对大家有帮助。</p>
<p>以下是一些在百度中找到的说法：<a href="http://zhidao.baidu.com/link?url=AMYxGo3NunWY7irH5XLPlHUa0ywvyqgYEAdDUMKJlQvklm686MC_D7ZjT3dX9BmuZWXXjWRV2QHelGJ8GzAxBK">http://zhidao.baidu.com/link?url=AMYxGo3NunWY7irH5XLPlHUa0ywvyqgYEAdDUMKJlQvklm686MC_D7ZjT3dX9BmuZWXXjWRV2QHelGJ8GzAxBK</a></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">java中，</span><br><span class="line">(1)对于字符串变量来说,equal比较的两边对象的内容，所以内容相同返回的是true。</span><br><span class="line">至于你没问到的“==”，比较的是内存中的首地址，所以如果不是同一个对象，“==”不会返回true 而是false。</span><br><span class="line">举个简单的例子，</span><br><span class="line">String s1=&quot;abc&quot;, s2=&quot;abc&quot;;</span><br><span class="line">String s3 =new String(&quot;abc&quot;);</span><br><span class="line">String s4=new String(&quot;abc&quot;);</span><br><span class="line">s1==s2 //true，</span><br><span class="line">s1.equals(s2) //true,</span><br><span class="line">s3.equals(s3) //true，equal比较的是内容</span><br><span class="line">s3==s4//false，==比较的是首地址，所以是false</span><br><span class="line">(2)对于非字符串变量，equals比较的内存的首地址，这时候和==是一样的，即比较两边指向的是不是同一个对象，</span><br><span class="line">即</span><br><span class="line">Sample sa1 = new Sample();</span><br><span class="line">Sample sa2 = new Sample();</span><br><span class="line">sa1.equals(sa2) //false，因为不是同一对象 </span><br><span class="line">注意，如果加上</span><br><span class="line">sa1=sa2;</span><br><span class="line">那么</span><br><span class="line">sa1.equals(sa2) //true</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>面经</category>
      </categories>
      <tags>
        <tag>Java基础</tag>
      </tags>
  </entry>
  <entry>
    <title>Java内部类的理解与使用</title>
    <url>/2021/11/20/innerclass/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h1 id="Java内部类的理解与使用"><a href="#Java内部类的理解与使用" class="headerlink" title="[Java内部类的理解与使用]"></a>[Java内部类的理解与使用]</h1><h1 id="内部类"><a href="#内部类" class="headerlink" title="内部类"></a>内部类</h1><h2 id="非静态内部类"><a href="#非静态内部类" class="headerlink" title="非静态内部类"></a>非静态内部类</h2><p>非静态内部类在使用常用的是直接放入类中，在使用过程中需要通过外部类的的对象才能调用。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public class OuterClass &#123;</span><br><span class="line">    public String outerName;</span><br><span class="line">    public OuterClass()&#123;</span><br><span class="line">        outerName = &quot;外部类&quot;;</span><br><span class="line">    &#125;</span><br><span class="line">    public void display()&#123;</span><br><span class="line">        System.out.println(outerName);</span><br><span class="line">    &#125;</span><br><span class="line">    class InnerClass&#123;</span><br><span class="line">        public String innerName;</span><br><span class="line">        public InnerClass()&#123;</span><br><span class="line">            innerName = &quot;内部类&quot;;</span><br><span class="line">        &#125;</span><br><span class="line">        public void display()&#123;</span><br><span class="line">            System.out.println(innerName);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        //外部类的创建</span><br><span class="line">        OuterClass outerClass = new OuterClass();</span><br><span class="line">        //外部类的使用</span><br><span class="line">        outerClass.display();</span><br><span class="line">        //内部类（类中）的创建</span><br><span class="line">        InnerClass  innerClass = outerClass.new InnerClass();</span><br><span class="line">        //内部类的使用</span><br><span class="line">        innerClass.display();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p> <img src="https://img2020.cnblogs.com/blog/2638700/202111/2638700-20211118151009853-344541367.png" alt="img"></p>
<p> 同样还能直接放入方法体中，那样就不需要使用外部类对象就可以直接调用</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public class OuterClass &#123;</span><br><span class="line">    public String outerName;</span><br><span class="line">    public OuterClass()&#123;</span><br><span class="line">        outerName = &quot;外部类&quot;;</span><br><span class="line">    &#125;</span><br><span class="line">    public void display()&#123;</span><br><span class="line">        System.out.println(outerName);</span><br><span class="line">        class InnerClass&#123;</span><br><span class="line">            public String innerName;</span><br><span class="line">            public InnerClass()&#123;</span><br><span class="line">                innerName = &quot;方法体中的内部类&quot;;</span><br><span class="line">            &#125;</span><br><span class="line">            public void display()&#123;</span><br><span class="line">                System.out.println(innerName);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        InnerClass innerClass = new InnerClass();</span><br><span class="line">        innerClass.display();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        //外部类的创建</span><br><span class="line">        OuterClass outerClass = new OuterClass();</span><br><span class="line">        //外部类的使用</span><br><span class="line">        outerClass.display();</span><br><span class="line">        //内部类（类中）的创建</span><br><span class="line"></span><br><span class="line">        //内部类的使用</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://img2020.cnblogs.com/blog/2638700/202111/2638700-20211118151250614-1592055606.png" alt="img"></p>
<h2 id="静态内部类"><a href="#静态内部类" class="headerlink" title="静态内部类"></a>静态内部类</h2><p>静态内部类可以直接通过类名进行调用，无需外部类的对象。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public class OuterClass &#123;</span><br><span class="line">    public String outerName;</span><br><span class="line">    public OuterClass()&#123;</span><br><span class="line">        outerName = &quot;外部类&quot;;</span><br><span class="line">    &#125;</span><br><span class="line">    public void display()&#123;</span><br><span class="line">        System.out.println(outerName);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static class InnerClass&#123;</span><br><span class="line">        public String innerName;</span><br><span class="line">        public InnerClass()&#123;</span><br><span class="line">            innerName = &quot;静态内部类&quot;;</span><br><span class="line">        &#125;</span><br><span class="line">        public void display()&#123;</span><br><span class="line">            System.out.println(innerName);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        //外部类的创建</span><br><span class="line">        OuterClass outerClass = new OuterClass();</span><br><span class="line">        //外部类的使用</span><br><span class="line">        outerClass.display();</span><br><span class="line">        //内部类（类中）的创建</span><br><span class="line">        InnerClass innerClass = new InnerClass();</span><br><span class="line">        //内部类的使用</span><br><span class="line">        innerClass.display();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://img2020.cnblogs.com/blog/2638700/202111/2638700-20211118151907063-283862776.png" alt="img"></p>
<h2 id="匿名内部类"><a href="#匿名内部类" class="headerlink" title="匿名内部类"></a>匿名内部类</h2><p>匿名内部类是最常见的内部类的使用方法，它针对接口（抽象类）可以直接使用，无需额外创建一个类来实现它的接口，同样它的缺点也很明显，耦合度高。</p>
<p> Pet.java</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public abstract class Pet &#123;</span><br><span class="line">    public abstract void eat();</span><br><span class="line">&#125;</span><br><span class="line">MyInterface.java</span><br><span class="line">public interface MyInterface &#123;</span><br><span class="line">    public void display();</span><br><span class="line">&#125;</span><br><span class="line">Test.java</span><br><span class="line">public class Test &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        //接口使用匿名内部类</span><br><span class="line">        MyInterface myInterface = new MyInterface() &#123;</span><br><span class="line">            @Override</span><br><span class="line">            public void display() &#123;</span><br><span class="line">                System.out.println(&quot;接口的匿名内部类的使用&quot;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        myInterface.display();</span><br><span class="line">        //抽象类使用匿名内部类</span><br><span class="line">        Pet pet = new Pet() &#123;</span><br><span class="line">            @Override</span><br><span class="line">            public void eat() &#123;</span><br><span class="line">                System.out.println(&quot;抽象类使用匿名内部类&quot;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        pet.eat();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://img2020.cnblogs.com/blog/2638700/202111/2638700-20211118152655743-1420739923.png" alt="img"></p>
]]></content>
      <categories>
        <category>面经</category>
      </categories>
      <tags>
        <tag>Java基础</tag>
      </tags>
  </entry>
</search>
